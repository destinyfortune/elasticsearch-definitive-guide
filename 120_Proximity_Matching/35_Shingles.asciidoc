[[shingles]]
=== 寻找相关单词

<<<<<<< HEAD
尽管短语查询和邻近查询很有用， 但是它们仍然有缺点。它们过于严格了： 短语查询要匹配， 所有的词
条必须都出现在文档中， 即使是使用了 `slop` 。((("proximity matching", "finding associated words", range="startofrange", id="ix_proxmatchassoc")))

用 `slop` 得到的单词顺序的灵活性也付出了代价， 因为失去了词组间的联系。 当你识别 `sue`, `alligator` 和 `ate` 一起
相邻出现的文档的时候， 你无法分辨是 _Sue ate_ 还是  _alligator ate_ 。

当单词相互结合使用的时候， 他们表达的意思比单独使用丰富。 这两个子句 _I'm not happy I'm working_ 和 _I'm happy I'm not working_ 包含同样
的单词， 也拥有相同的邻近度， 但是表达相当不同的意思。
=======
尽管短语查询和邻近查询很有用， 但是它们仍然有缺点。它们过于严格了： 短语查询要匹配， 所有的词条必须都出现在文档中， 即使是使用了 `slop`。((("proximity matching", "finding associated words", range="startofrange", id="ix_proxmatchassoc")))

用 `slop` 得到的单词顺序的灵活性也付出了代价， 因为失去了词组间的联系。 当你识别 `sue`, `alligator` 和 `ate` 一起相邻出现的文档的时候， 你无法分辨是 _Sue ate_ 还是  _alligator ate_ 。

当单词相互结合使用的时候， 他们表达的意思比单独使用丰富。 这两个子句 _I'm not happy I'm working_ 和 _I'm happy I'm not working_ 包含同样的单词， 也拥有相同的邻近度， 但是表达相当不同的意思。
>>>>>>> 8ca0a152b6c2e1afa79a6226c4c289ea889688f2

如果我们索引单词对而不是索引单独的单词，那么我们就能尽可能多的保留这些使用过这些单词的上下文。

对于这个句子 `Sue ate the alligator`, 我们不仅要将每一个单词(或者 _unigram_)作为词条索引((("unigrams")))

    ["sue", "ate", "the", "alligator"]

也要将每个单词 _以及它的邻近词_ 作为单个词条索引:

    ["sue ate", "ate the", "the alligator"]

这些单词对((("bigrams")))(或者说 _bigrams_)就被称为((("shingles")))_shingles_.

[TIP]
==================================================

Shingles不仅限于单词对； 你也能够索引三个单词(_trigrams_):

    ["sue ate the", "ate the alligator"]

Trigrams给了你更高的精度， 但是也大大增加了索引中唯一词条的数目。 在大多数情况下， Bigrams就够了。

==================================================

<<<<<<< HEAD
当然， 只有当用户输入的查询跟原始文档的顺序一样， shingles 才是有用的； 对 `sue alligator` 的查询可能会
匹配到单个单词， 但是不会匹配任何 shingles 。

幸运的是， 用户倾向于使用跟出现在他们搜索的数据相似的构造来表达查询。 但是这是很重要的一点：仅仅索引bigrams是
不够的； 我们仍然需要 unigrams ， 但是我们可以将匹配 bigrams 作为信号使用来增加相关度评分。

==== 生成 Shingles

Shingles 需要在索引时作为分析过程的一部分被创建。 ((("shingles", "producing at index time")))我们可以将 unigrams 和 bigrams 都索引到
一个字段中， 但是将它们放在分开字段中会更清晰， 也能够让它们被独立查询。unigrams 字段形成我们搜索的基础部分, 而 bigrams 字段用来提高相关度。
=======
当然， 只有当用户输入的查询跟原始文档的顺序一样， shingles才是有用的； 对 `sue alligator` 的查询可能会匹配到单个单词， 但是不会匹配任何shingles。

幸运的是， 用户倾向于使用跟出现在他们搜索的数据相似的构造来表达查询。 但是这是很重要的一点：仅仅索引bigrams是不够的； 我们仍然需要unigrams， 但是我们可以将匹配bigrams作为信号使用来增加相关度评分。

==== 生成Shingles

Shingles需要在索引时作为分析过程的一部分被创建。 ((("shingles", "producing at index time")))我们可以将unigrams和bigrams都索引到一个字段中， 但是将它们放在分开字段中会更清晰， 也能够让它们被独立查询。
unigrams字段形成我们搜索的基础部分, 而bigrams字段用来提高相关度。
>>>>>>> 8ca0a152b6c2e1afa79a6226c4c289ea889688f2

首先， 我们需要使用 `shingle` 语汇单元过滤器创建分析器：

[source,js]
--------------------------------------------------
DELETE /my_index

PUT /my_index
{
    "settings": {
        "number_of_shards": 1,  <1>
        "analysis": {
            "filter": {
                "my_shingle_filter": {
                    "type":             "shingle",
                    "min_shingle_size": 2, <2>
                    "max_shingle_size": 2, <2>
                    "output_unigrams":  false   <3>
                }
            },
            "analyzer": {
                "my_shingle_analyzer": {
                    "type":             "custom",
                    "tokenizer":        "standard",
                    "filter": [
                        "lowercase",
                        "my_shingle_filter" <4>
                    ]
                }
            }
        }
    }
}
--------------------------------------------------
// SENSE: 120_Proximity_Matching/35_Shingles.json

<1> 参考 <<relevance-is-broken>>。
<<<<<<< HEAD
<2> 默认最小/最大的 shingle 大小是 `2`, 所以我们实际上不用设置。
<3> `shingle` 语汇单元过滤器默认输出 unigrams ， 但是我们想让 unigrams 和 bigrams 分开。
=======
<2> 默认最小/最大的shingle大小是 `2`, 所以我们实际上不用设置。
<3> `shingle` 语汇单元过滤器默认输出unigrams， 但是我们想让unigrams和bigrams分开。
>>>>>>> 8ca0a152b6c2e1afa79a6226c4c289ea889688f2
<4> `my_shingle_analyzer` 使用我们常规的 `my_shingles_filter` 语汇单元过滤器。

首先， 让我们用 `analyze` API测试下我们的分析器:

[source,js]
--------------------------------------------------
GET /my_index/_analyze?analyzer=my_shingle_analyzer
Sue ate the alligator
--------------------------------------------------

果然， 我们得到了 3 个词条：

* `sue ate`
* `ate the`
* `the alligator`

现在我们可以继续创建一个使用新的分析器的字段。

==== 多字段

<<<<<<< HEAD
我们说将 unigrams 和 bigrams 分开索引更清晰， 所以我们将 `title` 字段 ((("multifields")))创建成一个多字段(参考 <<multi-fields>>)：
=======
我们说将unigrams和bigrams分开索引更清晰， 所以我们将 `title` 字段 ((("multifields")))创建成一个多字段(参考 <<multi-fields>>)：
>>>>>>> 8ca0a152b6c2e1afa79a6226c4c289ea889688f2

[source,js]
--------------------------------------------------
PUT /my_index/_mapping/my_type
{
    "my_type": {
        "properties": {
            "title": {
                "type": "string",
                "fields": {
                    "shingles": {
                        "type":     "string",
                        "analyzer": "my_shingle_analyzer"
                    }
                }
            }
        }
    }
}
--------------------------------------------------

<<<<<<< HEAD
通过这个映射， JSON文档中的 `title` 字段将会被以 unigrams(`title`) 和 bigrams(`title.shingles`) 被索引, 这意味着我们可以独立地查询这些字段。

最后， 我们可以索引示例文档:
=======
通过这个映射， JSON文档中的 `title` 字段将会被以unigrams(`title`)和bigrams(`title.shingles`)被索引, 这意味着我们可以独立地查询这些字段。

最后， 我们可以索引示例文档：
>>>>>>> 8ca0a152b6c2e1afa79a6226c4c289ea889688f2

[source,js]
--------------------------------------------------
POST /my_index/my_type/_bulk
{ "index": { "_id": 1 }}
{ "title": "Sue ate the alligator" }
{ "index": { "_id": 2 }}
{ "title": "The alligator ate Sue" }
{ "index": { "_id": 3 }}
{ "title": "Sue never goes anywhere without her alligator skin purse" }
--------------------------------------------------

<<<<<<< HEAD
==== 搜索 Shingles

为了理解添加 `shingles` 字段的好处 ((("shingles", "searching for")))， 让我们首先看看一个对 ``The hungry alligator ate Sue`` 的一个
简单 `match` 查询结果：
=======
==== 搜索Shingles

为了理解添加 `shingles` 字段的好处 ((("shingles", "searching for")))， 让我们首先看看一个对 ``The hungry alligator ate Sue`` 的一个简单 `match` 查询结果：
>>>>>>> 8ca0a152b6c2e1afa79a6226c4c289ea889688f2

[source,js]
--------------------------------------------------
GET /my_index/my_type/_search
{
   "query": {
        "match": {
           "title": "the hungry alligator ate sue"
        }
   }
}
--------------------------------------------------

这个查询返回了所有的三个文档， 但是注意文档 1 和 2 有相同的相关度评分因为他们包含了相同的单词：

[source,js]
--------------------------------------------------
{
  "hits": [
     {
        "_id": "1",
        "_score": 0.44273707, <1>
        "_source": {
           "title": "Sue ate the alligator"
        }
     },
     {
        "_id": "2",
        "_score": 0.44273707, <1>
        "_source": {
           "title": "The alligator ate Sue"
        }
     },
     {
        "_id": "3", <2>
        "_score": 0.046571054,
        "_source": {
           "title": "Sue never goes anywhere without her alligator skin purse"
        }
     }
  ]
}
--------------------------------------------------
<<<<<<< HEAD
<1> 两个文档都包含 `the`, `alligator` 和 `ate`, 所以获得同样的评分。
<2> 我们本可以通过设置 `minimum_should_match` 参数排除文档 3。

现在让我们往查询里添加 `shingles` 字段。 记住我们想要将 `shingles` 字段上的匹配作为一
种信号--为了提高相关度评分--所以我们仍然需要将主要 `title` 字段包含到查询中：
=======

<1> 两个文档都包含 `the`, `alligator` 和 `ate`, 所以获得同样的评分。
<2> 我们本可以通过设置 `minimum_should_match` 参数排除文档 3。

现在让我们往查询里添加 `shingles` 字段。 记住我们想要将 `shingles` 字段上的匹配作为一种信号--为了提高相关度评分--所以我们仍然需要将主要 `title` 字段包含到查询中：
>>>>>>> 8ca0a152b6c2e1afa79a6226c4c289ea889688f2

[source,js]
--------------------------------------------------
GET /my_index/my_type/_search
{
   "query": {
      "bool": {
         "must": {
            "match": {
               "title": "the hungry alligator ate sue"
            }
         },
         "should": {
            "match": {
               "title.shingles": "the hungry alligator ate sue"
            }
         }
      }
   }
}
--------------------------------------------------

<<<<<<< HEAD
我们仍然匹配到了所有的 3 个文档， 但是文档 2 现在排到了第一名因为它匹配了 shingled 词条 `ate sue`.
=======
我们仍然匹配到了所有的 3 个文档， 但是文档 2 现在排到了第一名因为它匹配了shingled词条 `ate sue`.
>>>>>>> 8ca0a152b6c2e1afa79a6226c4c289ea889688f2

[source,js]
--------------------------------------------------
{
  "hits": [
     {
        "_id": "2",
        "_score": 0.4883322,
        "_source": {
           "title": "The alligator ate Sue"
        }
     },
     {
        "_id": "1",
        "_score": 0.13422975,
        "_source": {
           "title": "Sue ate the alligator"
        }
     },
     {
        "_id": "3",
        "_score": 0.014119488,
        "_source": {
           "title": "Sue never goes anywhere without her alligator skin purse"
        }
     }
  ]
}
--------------------------------------------------

即使我们的查询包含了没有在任何文档中出现的单词 `hungry`, 我们仍然使用单词邻近度返回了最相关的文档。

==== 性能

<<<<<<< HEAD
shingles 不仅比短语查询更灵活， ((("shingles", "better performance than phrase queries")))而且它们性能也更好。 每次搜索的时候都不用花费短语查询的代价，
shingles 查询跟一个简单的 `match` 查询一样高效。 只是在索引期间会付出较小代价因为更多词条需要被索引， 这也意味着有 shingles 的字段占用了更多的磁盘空间。 然而，大多数应用写入一次而读取多次， 所以在索引期间优化我们的快速查询是有意义的。
=======
shingles不仅比短语查询更灵活， ((("shingles", "better performance than phrase queries")))而且它们性能也更好。 每次搜索的时候都不用花费短语查询的代价，
shingles查询跟一个简单的 `match` 查询一样高效。 只是在索引期间会付出较小代价因为更多词条需要被索引， 这也意味着有shingles的字段占用了更多的磁盘空间。 然而，大多数应用写入一次而读取多次， 所以在索引期间优化我们的快速查询是有意义的。

这是一个你在Elasticsearch里会经常碰到的主题： 让你能够在搜索的时候不用需要任何前期设置实现很多东西。 一旦你更清晰的理解了自己的需求， 你就能在索引时通过正确的为你的数据建模用更好的性能获得更好的结果。((("proximity matching", "finding associated words", range="endofrange", startref ="ix_proxmatchassoc")))
>>>>>>> 8ca0a152b6c2e1afa79a6226c4c289ea889688f2

这是一个你在 Elasticsearch 里会经常碰到的主题： 让你能够在搜索的时候不用需要任何前期设置实现很多东西。 一旦你更清晰的理解了自己的需求， 你就能在索引时通过正确的为你的数据建模用更好的性能获得更好的结果。((("proximity matching", "finding associated words", range="endofrange", startref ="ix_proxmatchassoc")))
